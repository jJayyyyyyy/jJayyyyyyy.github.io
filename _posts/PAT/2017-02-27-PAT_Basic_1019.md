---
layout: pat
title: PAT Basic 1019
---


本题代码可以参考[这里](https://github.com/jJayyyyyyy/cs/tree/master/OJ/PAT/basic_level/1019_%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E)。

<br/>

##	[原题](https://www.patest.cn/contests/pat-b-practise/1019)： 1019. 数字黑洞 (20)

给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。

例如，我们从6767开始，将得到

	7766 - 6677 = 1089
	9810 - 0189 = 9621
	9621 - 1269 = 8352
	8532 - 2358 = 6174
	7641 - 1467 = 6174
	... ...

现给定任意4位正整数，请编写程序演示到达黑洞的过程。

###	输入格式

输入给出一个(0, 10000)区间内的正整数N。

###	输出格式

如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。

###	输入样例1

	6767

###	输出样例1

	7766 - 6677 = 1089
	9810 - 0189 = 9621
	9621 - 1269 = 8352
	8532 - 2358 = 6174

###	输入样例2

	2222

###	输出样例2

	2222 - 2222 = 0000

###	注意

	时间限制： 100 ms
	内存限制： 65536 kB
	代码长度限制： 8000 B
	判题程序： Standard
	作者： CHEN, Yue

<br/><br/>

#	题目分析

1.	输入分类

	输入分为两类，其一如样例1，四个数字不全相同。其二如样例2，四个数字全都相同。

2.	第一类输入

	注意输出的时候需要`补全`4位数字，比如计算结果是`189`，那么需要输出`0189`。

	灵活运用`sprintf()`和`atoi()`可以方便地进行【数字】和【字符串】之间的转换。若是用C++，则可以借助`stringstream`类作为过渡。

3.	第二类输入

	直接输出`N - N = 0000`

#	部分测试用例

*	test1

		输入
		6767

		输出
		7766 - 6677 = 1089
		9810 - 0189 = 9621
		9621 - 1269 = 8352
		8532 - 2358 = 6174

*	test2

		输入
		2222

		输出
		2222 - 2222 = 0000

*	test3

		输入
		1

		输出
		1000 - 0001 = 0999
		9990 - 0999 = 8991
		9981 - 1899 = 8082
		8820 - 0288 = 8532
		8532 - 2358 = 6174
		
<br/>

(END)
